# Анализ и эволюция архитектурной модели

## Введение
Данный документ описывает эволюцию модели архитектуры в проекте "ConsoleAppDI". В процессе работы над проектом мы несколько раз пересматривали архитектурное решение, начиная с формулировки требований и заканчивая финальной реализацией модели архитектуры. В этом документе рассмотрены ошибки, сделанные на пути к итоговому решению, корректировки и шаги, которые привели к оптимальному результату.

---

## Этап 1: Формулировка первоначальной модели

### 1.1. Первоначальная модель архитектуры
На первом этапе, когда мы начали работу над архитектурой, модель была представлена как простое перечисление классов и зависимостей. Были выделены такие компоненты как `IMessenger`, `Sender`, и различные реализации `IMessenger`, но сама структура не была представлена как _слоистая модель_, что затрудняло понимание взаимосвязей и ролей компонентов.

### 1.2. Ошибки на первом этапе
- Не было ясно, какие слои отвечают за какие функциональные области системы.
- Не было выделено четкой абстракции, определяющей, как система будет взаимодействовать на разных уровнях.
- Описание зависимостей не отображало архитектурную логику, а лишь технические связи между классами.

**Ошибка:** Проектирование на этом этапе не отражало системный подход, нуждающийся в четкой организации слоев и абстракций.

---

## Этап 2: Ревизия модели и разделение на слои

### 2.1. Описание слоев
После детального обсуждения и анализа архитектуры, мы пришли к необходимости выделения **слоёв** в архитектуре. Важным шагом было признание того, что каждый компонент системы должен отвечать за свою часть функционала, и архитектура должна поддерживать эту изоляцию. На этом этапе были добавлены слои:
- Слой **Дизайна**, который отвечает за требования.
- Слой **Абстракций**, который содержит контракт для взаимодействия между слоями.
- Слой **Координатора**, который связывает слои и управляет их взаимодействием.
- Слой **Исполнителей**, который реализует конкретные сценарии.
- Слой **Тестирования**, который проверяет корректность выполнения контрактов.

### 2.2. Ошибки на втором этапе
- **Избыточность и недочеты в слоях**: Мы начали определять слои, но в процессе некоторые из них казались не совсем логичными. Например, слой "Тестирования" был скорее техническим дополнением, чем архитектурной частью.
- **Сложности в изоляции зависимостей**: Некоторые компоненты зависели напрямую друг от друга без явной инверсии зависимостей, что затрудняло тестирование и расширение.

**Ошибка:** Некоторые слои были сформулированы без должного понимания их архитектурной роли и важности слабой связанности между ними.

---

## Этап 3: Окончательная доработка и выделение абстракций

### 3.1. Улучшение абстракций и зависимостей
На этом этапе мы начали более тщательно работать с абстракциями. В результате выделения слоя **Абстракций** мы чётко обозначили, что вся система должна опираться на контракт, обеспечиваемый интерфейсом `IMessenger`. Также мы стали явно указывать, что DI будет использоваться для инверсии зависимостей.

### 3.2. Описание ключевых зависимостей
- **Интерфейс `IMessenger`** стал ключевой абстракцией, связывающей все компоненты системы.
- Мы обозначили **точки инверсии зависимостей** (например, в классе `Sender`), что обеспечило гибкость и расширяемость архитектуры.
- **DI** теперь чётко воспринимался как инфраструктурный механизм, который связывает абстракции с их реализациями, обеспечивая слабую связанность и простоту тестирования.

### 3.3. Ошибки на третьем этапе
- Некоторые из слоев все ещё оставались абстрактными в плане объяснения их точной роли. Например, входной слой не был достаточно чётко описан с точки зрения управления зависимостями.
- Мы продолжали работать с тестами, но не всегда видели их связь с реальной архитектурой, а лишь как отдельный элемент.

**Ошибка:** Проблемы с выделением точных ролей каждого слоя и недостаточное внимание к взаимосвязям между слоями.

---

## Этап 4: Окончательная версия модели архитектуры

### 4.1. Оптимизация структуры слоёв
На финальном этапе мы пришли к следующей оптимальной модели архитектуры:
1. **Слой Дизайна**: Это не просто требования, но и критерии их выполнения, которые трансформируются в абстракции.
2. **Слой Абстракций**: Включает интерфейс `IMessenger` как контракт, который изолирует слои координаторов и исполнителей, обеспечивая слабую связанность.
3. **Слой Входных данных**: Этот слой теперь не только принимает данные, но и инициализирует зависимости через DI, что добавляет гибкости.
4. **Слой Координатора**: Ответственен за управление взаимодействием компонентов, изолирует логику от деталей реализации.
5. **Слой Исполнителей**: Реализует различные варианты обработки данных, но всегда через общий контракт, обеспечивая заменяемость и расширяемость.
6. **Слой Тестирования**: Проверяет все важные контрактные взаимодействия между слоями и гарантирует соответствие требованиям.

### 4.2. Почему итоговая модель оптимальна:
- **Слоистая модель** теперь чётко разделяет ответственность между различными уровнями системы. Каждый слой выполняет свою роль и минимально зависит от других слоёв.
- **Абстракции и DI** обеспечивают возможность замены и модификации компонентов без изменения других частей системы.
- **Поведение и расширяемость** теперь чётко поддерживаются за счет выделения абстракций и контрактов.
- **Тестирование** стало неотъемлемой частью архитектуры, проверяя все ключевые взаимодействия и гарантируя соответствие требованиям.

---

## Заключение
Каждый этап разработки архитектуры помог нам прийти к оптимальной модели, которая обеспечивает гибкость, расширяемость и минимизацию зависимости между слоями. Итоговая модель архитектуры является результатом постоянных корректировок и анализа требований, который позволил нам найти правильное разделение обязанностей и обеспечить простоту тестирования и расширения системы.

---

**Название документа**: `04_architectural_modeling_analysis.md`
